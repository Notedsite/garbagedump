<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FRANKENSTEIN V3.0 - NEURAL LINK</title>
<style>
    /* LABORATORY / GITHUB PAGES COMPATIBLE CSS */
    :root {
        --screen-bg: #0d0d0d;
        --glass-bg: #001100;
        --primary: #33ff00;
        --accent: #9dff80;
        --user: #ffff00;
        --ui-border: #1a5c00;
        --dim: #1e4d0d;
        --highlight: #ff00ff; /* Glitch aesthetic */
    }

    body {
        background-color: var(--screen-bg);
        color: var(--primary);
        font-family: 'Courier New', Courier, monospace;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    /* HEADER */
    header {
        width: 100%;
        background: #000;
        border-bottom: 2px solid var(--primary);
        padding: 10px 0;
        text-align: center;
        box-shadow: 0 0 15px var(--ui-border);
    }
    h1 { margin: 0; text-shadow: 0 0 5px var(--primary); font-size: 1.5rem; letter-spacing: 2px; }

    /* MAIN CONTAINER */
    #container {
        display: flex;
        flex-direction: column;
        width: 95%;
        max-width: 900px;
        height: 90vh;
        margin-top: 10px;
        gap: 10px;
    }

    /* TERMINAL LOG */
    #terminal {
        flex-grow: 1;
        border: 1px solid var(--primary);
        background-color: var(--glass-bg);
        padding: 15px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 14px;
        box-shadow: inset 0 0 30px rgba(51, 255, 0, 0.1);
        scrollbar-width: thin;
        scrollbar-color: var(--primary) var(--glass-bg);
        background-image: linear-gradient(0deg, transparent 24%, rgba(51, 255, 0, .03) 25%, rgba(51, 255, 0, .03) 26%, transparent 27%, transparent 74%, rgba(51, 255, 0, .03) 75%, rgba(51, 255, 0, .03) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(51, 255, 0, .03) 25%, rgba(51, 255, 0, .03) 26%, transparent 27%, transparent 74%, rgba(51, 255, 0, .03) 75%, rgba(51, 255, 0, .03) 76%, transparent 77%, transparent);
        background-size: 50px 50px;
    }

    .log-entry { margin-bottom: 4px; color: #4b8f3d; font-size: 0.8em; }
    .ai-speak { color: var(--accent); font-weight: bold; margin: 15px 0; display: block; text-shadow: 0 0 4px var(--accent); padding: 5px; border-left: 3px solid var(--accent); }
    .user-speak { color: var(--user); margin-top: 10px; display: block; padding-left: 10px; }
    
    /* CONTROL PANEL */
    #control-panel {
        border: 1px solid var(--ui-border);
        background: #000;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .settings-row {
        display: flex;
        justify-content: flex-start;
        flex-wrap: wrap;
        gap: 20px;
        border-bottom: 1px dashed var(--dim);
        padding-bottom: 8px;
        margin-bottom: 5px;
    }

    label { font-size: 0.85em; user-select: none; display: flex; align-items: center; gap: 5px; color: #88ff88; cursor: pointer; }
    label:hover { color: #fff; }

    /* INPUTS */
    input[type="range"] { accent-color: var(--primary); width: 100px; cursor: pointer; }
    input[type="checkbox"] { accent-color: var(--primary); cursor: pointer; width: 16px; height: 16px; }
    
    #input-row { display: flex; gap: 10px; }
    
    input[type="text"] {
        flex-grow: 1;
        background: #0a0a0a;
        border: 1px solid var(--primary);
        color: var(--primary);
        padding: 12px;
        font-family: inherit;
        font-size: 1.1em;
    }
    input[type="text"]:focus { outline: none; background: #000; box-shadow: 0 0 10px var(--ui-border); }

    button {
        background: var(--primary);
        color: #000;
        border: none;
        padding: 0 25px;
        font-weight: bold;
        font-family: inherit;
        cursor: pointer;
        font-size: 1.1em;
        transition: 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    button:hover { background: #fff; box-shadow: 0 0 15px var(--primary); }
    button:disabled { background: var(--dim); color: #555; cursor: not-allowed; box-shadow: none; }

    #word-counter {
        margin-left: auto;
        font-size: 0.8rem;
        color: #555;
    }

</style>
</head>
<body>

    <header>
        <h1>PROJECT FRANKENSTEIN V3.0</h1>
    </header>

    <div id="container">
        
        <div id="terminal">System Initialized... Logic Gates Active...
Memory: READY.
Loop Protection: ENABLED.
Ending Mutation: ONLINE.</div>

        <div id="control-panel">
            
            <div class="settings-row">
                <label title="Prevents a valid sentence from ending immediately after the first word.">
                    <input type="checkbox" id="chkFirstWordSafe" checked> 
                    First Word Immunity
                </label>
                
                <label title="Prevents the machine from choosing word A, then B, then A again (Word Bounce).">
                    <input type="checkbox" id="chkLoopSafety" checked>
                    Loop Safety
                </label>

                <label>
                    <span>Min Sentences:</span>
                    <input type="range" id="sldMinLen" min="1" max="10" value="1" oninput="document.getElementById('lenVal').innerText = this.value">
                    <span id="lenVal">1</span>
                </label>

                <div id="word-counter"></div>
            </div>

            <div id="input-row">
                <input type="text" id="userInput" placeholder="Data Input Required..." autocomplete="off">
                <button id="sendBtn" onclick="runFrankenstein()">TRANSMIT</button>
            </div>
        </div>

    </div>

<script>
    // =========================================================
    // THE DICTIONARY
    // Updated structure with ENDINGS (sub-table) and refined Grammar types
    // 'v_act' (Eat, run) vs 'v_link' (Is, Am) prevents "Tornado eat friendly".
    // =========================================================
    
    // TEMPLATE: Who can follow who?
    const COMPATIBLES_TEMPLATE = {
        n:      ["v_act", "v_link", "con", "pre", "pun"], // Noun -> Action, Linking Verb, etc
        v_act:  ["n", "pre", "art", "pro", "adv"], // Actions target Nouns (run to..., eat apple...)
        v_link: ["adj", "art", "n", "v_act"],      // Linking targets Adjectives (is happy, is a...)
        adj:    ["n", "pun", "con", "pre"], 
        art:    ["n", "adj"], 
        pro:    ["v_act", "v_link", "modal"], // Pronouns hit Verbs
        pre:    ["n", "art", "pro"], // Prepositions need Objects
        con:    ["pro", "n", "art"], // Conjunctions restart
        adv:    ["v_act", "adj", "pun"],
        modal:  ["v_act", "v_link", "pro"],
        greet:  ["pun", "pro", "n"],
        pun:    ["end", "start"] 
    };

    const DICTIONARY = {
        // SYSTEM
        "start_token": { pos: "start", tags: [], endings: [] },

        // GREETINGS
        "hello": { pos: "greet", tags: ["greeting", "friendly"], endings: [] },
        "hi":    { pos: "greet", tags: ["greeting", "casual"], endings: [] },
        "hey":   { pos: "greet", tags: ["greeting", "casual"], endings: [] },

        // MODALS
        "can": { pos: "modal", tags: ["question", "ability"], endings: ["'t"] },
        "will":{ pos: "modal", tags: ["future", "promise"], endings: ["'t"] },
        "do":  { pos: "modal", tags: ["action", "question"], endings: ["n't", "ing"] },

        // PRONOUNS
        "i":   { pos: "pro", tags: ["self", "identity", "creator"], endings: ["'m", "'ve"] },
        "you": { pos: "pro", tags: ["user", "human", "outside"], endings: ["'re", "'ve"] },
        "it":  { pos: "pro", tags: ["object", "thing"], endings: ["'s"] },
        "we":  { pos: "pro", tags: ["group", "unity"], endings: ["'re"] },
        "he":  { pos: "pro", tags: ["male", "living"], endings: ["'s"] },
        "she": { pos: "pro", tags: ["female", "living"], endings: ["'s"] },

        // NOUNS 
        "human":   { pos: "n", tags: ["living", "user", "biology"], endings: ["s"] },
        "monster": { pos: "n", tags: ["self", "scary", "science"], endings: ["s"] },
        "machine": { pos: "n", tags: ["self", "tech", "metal"], endings: ["s"] },
        "tornado": { pos: "n", tags: ["weather", "disaster", "danger", "wind"], endings: ["s"] },
        "rain":    { pos: "n", tags: ["weather", "wet", "water", "sad"], endings: [] },
        "sun":     { pos: "n", tags: ["weather", "hot", "fire", "light"], endings: ["light"] },
        "fire":    { pos: "n", tags: ["element", "hot", "danger", "burn"], endings: ["place"] },
        "data":    { pos: "n", tags: ["tech", "knowledge", "science"], endings: ["base"] },
        "cat":     { pos: "n", tags: ["animal", "living", "soft"], endings: ["s"] },
        "sky":     { pos: "n", tags: ["location", "up", "blue", "vast"], endings: [] },
        "god":     { pos: "n", tags: ["power", "religion"], endings: ["s"] },
        "time":    { pos: "n", tags: ["physics", "long"], endings: ["s"] },

        // VERBS - STATE (Linking: Is, Am, Are)
        "is":   { pos: "v_link", tags: ["exist", "state"], endings: ["n't"] },
        "am":   { pos: "v_link", tags: ["exist", "self"], endings: [] },
        "are":  { pos: "v_link", tags: ["exist", "plural"], endings: ["n't"] },
        "was":  { pos: "v_link", tags: ["exist", "past"], endings: ["n't"] },

        // VERBS - ACTION (Run, Eat)
        "run":  { pos: "v_act", tags: ["action", "fast", "fear"], endings: ["s", "ning"] },
        "know": { pos: "v_act", tags: ["thought", "knowledge", "data"], endings: ["s", "ing"] },
        "see":  { pos: "v_act", tags: ["sense", "vision", "watch"], endings: ["s", "ing"] },
        "feel": { pos: "v_act", tags: ["sense", "emotion", "touch"], endings: ["s", "ing"] },
        "kill": { pos: "v_act", tags: ["violence", "death", "bad"], endings: ["s", "ing", "ed"] },
        "love": { pos: "v_act", tags: ["emotion", "good", "heart"], endings: ["s", "ing", "ed"] },
        "fear": { pos: "v_act", tags: ["emotion", "scary", "bad"], endings: ["s", "ing", "ed"] },
        "eat":  { pos: "v_act", tags: ["action", "biology"], endings: ["s", "ing", "en"] },
        "make": { pos: "v_act", tags: ["action", "create", "build"], endings: ["s", "ing"] },
        "break":{ pos: "v_act", tags: ["action", "bad", "destroy"], endings: ["s", "ing"] },
        
        // ADJECTIVES
        "happy":    { pos: "adj", tags: ["emotion", "good"], endings: [] },
        "sad":      { pos: "adj", tags: ["emotion", "bad", "wet"], endings: [] },
        "angry":    { pos: "adj", tags: ["emotion", "mad", "fire"], endings: [] },
        "dangerous":{ pos: "adj", tags: ["danger", "scary", "caution"], endings: [] },
        "dead":     { pos: "adj", tags: ["biology", "end"], endings: [] },
        "cold":     { pos: "adj", tags: ["weather", "feeling"], endings: [] },
        "hot":      { pos: "adj", tags: ["weather", "fire"], endings: [] },
        "blue":     { pos: "adj", tags: ["color", "sky", "water"], endings: [] },
        "red":      { pos: "adj", tags: ["color", "blood", "fire"], endings: [] },

        // ARTICLES
        "the": { pos: "art", tags: ["specific"], endings: [] },
        "a":   { pos: "art", tags: ["general"], endings: [] },
        "my":  { pos: "art", tags: ["possession"], endings: [] },
        "your":{ pos: "art", tags: ["possession", "user"], endings: [] },

        // CONJUNCTIONS
        "and": { pos: "con", tags: ["connect", "logic"], endings: [] },
        "but": { pos: "con", tags: ["contrast", "logic"], endings: [] },
        
        // PREPOSITIONS
        "with": { pos: "pre", tags: ["connection"], endings: [] },
        "to":   { pos: "pre", tags: ["direction"], endings: [] },
        "in":   { pos: "pre", tags: ["location"], endings: [] },
        "on":   { pos: "pre", tags: ["location"], endings: [] },

        // PUNCTUATION 
        // comp: explicit list of what can follow
        ".": { pos: "pun", tags: ["end"], endings: [], comp: ["end"] },
        "?": { pos: "pun", tags: ["end"], endings: [], comp: ["end"] },
        "!": { pos: "pun", tags: ["end"], endings: [], comp: ["end"] },
        ",": { pos: "pun", tags: ["pause"], endings: [], comp: ["n", "v_act", "v_link", "pro", "con"] },
    };

    // Calculate DB Size
    document.getElementById("word-counter").innerText = "CORE MEMORY: " + Object.keys(DICTIONARY).length + " CLUSTERS";

    // =========================================================
    // SYSTEM CORE
    // =========================================================

    const terminal = document.getElementById('terminal');
    const inputField = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    
    // Controls
    const sliderMinLen = document.getElementById('sldMinLen');
    const checkStartSafe = document.getElementById('chkFirstWordSafe');
    const checkLoopSafe = document.getElementById('chkLoopSafety');

    function log(text, type = 'log-entry') {
        const div = document.createElement('div');
        div.className = type;
        div.innerText = text;
        terminal.appendChild(div);
        terminal.scrollTop = terminal.scrollHeight;
    }

    function runFrankenstein() {
        const question = inputField.value.trim().toLowerCase();
        if(!question) return;

        // UI Freeze
        inputField.value = "";
        inputField.disabled = true;
        sendBtn.disabled = true;
        
        log("> USER: " + question, 'user-speak');
        log(":: SCANNING LEXICON FOR VECTOR MATCHES...", "log-entry");

        // -----------------------------
        // 1. INPUT ANALYSIS
        // -----------------------------
        const contextTags = new Set();
        // Simple tokenizer
        const inputWords = question.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/);
        
        inputWords.forEach(w => {
            let foundWord = null;

            // Direct Check
            if (DICTIONARY[w]) {
                foundWord = w;
            } else {
                // Levenshtein fuzzy scan
                let bestD = 100; 
                let match = "";
                Object.keys(DICTIONARY).forEach(key => {
                    const d = levenshtein(w, key);
                    if (d < bestD) { bestD = d; match = key; }
                });
                
                // Allow fuzzy if close enough
                if (bestD <= 2) foundWord = match;
            }

            if(foundWord && foundWord !== "start_token") {
                DICTIONARY[foundWord].tags.forEach(tag => contextTags.add(tag));
            }
        });

        const ctxArray = Array.from(contextTags);
        // Force random topic if empty to avoid pure gibberish
        if (ctxArray.length === 0) {
            ctxArray.push("exist");
            log(":: INPUT VAGUE. DEFAULTING TO EXISTENTIAL PARAMETERS.", "log-entry");
        } else {
            log(`:: PARAMETERS DETECTED: [${ctxArray.join(" / ")}]`, "log-entry");
        }

        // -----------------------------
        // 2. GENERATION LOOP
        // -----------------------------
        let sentenceWords = []; // Array of pure words
        let prevWordObj = DICTIONARY["start_token"];
        
        // Counters
        let wordsGenerated = 0;
        const limit = 20; // Hard cap

        const loop = () => {
            const minLengthTarget = parseInt(sliderMinLen.value);
            const isLoopSafe = checkLoopSafe.checked;
            
            // Hard Limit Break
            if (wordsGenerated >= limit) {
                finalizeSentence(sentenceWords);
                return;
            }

            // A. Get Allowed POS (Types) based on previous word
            let allowedPOS = [];
            
            if (prevWordObj.comp) {
                // Explicit overrides (e.g., Punctuation overrides defaults)
                allowedPOS = prevWordObj.comp;
            } else {
                // Use template
                allowedPOS = COMPATIBLES_TEMPLATE[prevWordObj.pos] || ["n", "pro"];
            }

            // Safety Filters
            if (wordsGenerated === 0 && checkStartSafe.checked) {
                allowedPOS = allowedPOS.filter(p => p !== "pun" && p !== "end");
            }
            if (wordsGenerated < minLengthTarget) {
                allowedPOS = allowedPOS.filter(p => p !== "pun" && p !== "end");
            }

            // B. Filter Dictionary for Candidates
            let candidates = [];
            
            Object.keys(DICTIONARY).forEach(key => {
                if (key === "start_token") return;
                const entry = DICTIONARY[key];

                // Must match grammar rule
                if (allowedPOS.includes(entry.pos)) {
                    
                    // Loop Safety Check
                    if (isLoopSafe) {
                        // Check last 2 words to avoid rebound (A B A)
                        if (sentenceWords.length > 0 && sentenceWords[sentenceWords.length-1] === key) return; // Immediate duplicate
                        if (sentenceWords.length > 1 && sentenceWords[sentenceWords.length-2] === key) return; // Rebound duplicate
                    }

                    // --- SCORING ALGORITHM ---
                    let score = 0;

                    // 1. Context Relevance
                    entry.tags.forEach(t => {
                        if (ctxArray.includes(t)) score += 20; 
                    });

                    // 2. Input Structure Matching (Levenshtein against inputs)
                    if (inputWords.length > 0) {
                        inputWords.forEach(inp => {
                            let dist = levenshtein(key, inp);
                            if (dist < 3) score += (5 - dist);
                        });
                    }

                    // 3. Greeting Anti-Loop
                    // If we already outputted a greeting, severely penalize doing it again
                    if (entry.pos === "greet" && wordsGenerated > 0) score -= 100;
                    
                    // 4. Grammar Bias (Action vs State)
                    // Reduce chance of random nonsense adjectives appearing where not strictly needed
                    if (entry.pos === "adj" && Math.random() > 0.6) score -= 5;

                    // 5. Ending Weight
                    if (entry.pos === "pun" && wordsGenerated > minLengthTarget + 2) score += 30;

                    candidates.push({ word: key, score: score, entry: entry });
                }
            });

            // Handle Dead Ends (No grammar match)
            if (candidates.length === 0) {
                candidates.push({ word: ".", score: 999, entry: DICTIONARY["."] });
            }

            // Sort High to Low
            candidates.sort((a,b) => b.score - a.score + (Math.random() * 5));
            const winner = candidates[0];

            // STOP Condition
            if (winner.word === "end" || (winner.entry.pos === "pun" && winner.entry.tags.includes("end"))) {
                // If it picked a period, push it and stop
                if(winner.word !== "end") sentenceWords.push(winner.word);
                finalizeSentence(sentenceWords);
                return;
            }

            // --- ENDING MUTATION (The New Sub-Table Logic) ---
            let finalWordString = winner.word;
            // 30% chance to mutate if endings exist
            if (winner.entry.endings.length > 0 && Math.random() > 0.6) {
                const ending = winner.entry.endings[Math.floor(Math.random() * winner.entry.endings.length)];
                log(`..mutating [${finalWordString}] + [${ending}]`, "log-entry");
                finalWordString += ending;
            }

            // Log decision
            log(`..linked [${finalWordString}] (Score:${winner.score.toFixed(0)})`, "log-entry");

            sentenceWords.push(finalWordString);
            prevWordObj = winner.entry; // Pass the base dictionary entry logic forward
            wordsGenerated++;

            setTimeout(loop, 400);
        };

        // START
        setTimeout(loop, 400);
    }

    function finalizeSentence(words) {
        if(words.length === 0) return;

        let output = "";
        
        // Capitalize First Word Only logic
        for(let i=0; i<words.length; i++) {
            let w = words[i];

            if (i === 0) {
                // Standard Cap
                w = w.charAt(0).toUpperCase() + w.slice(1);
            }

            const isPunctuation = (w.length === 1 && [".","!","?",","].includes(w));
            
            if (isPunctuation) {
                output += w; // no space
            } else if (i > 0) {
                output += " " + w; // space before next word
            } else {
                output += w;
            }
        }

        log("> ENTITY: " + output, 'ai-speak');
        
        // Reset controls
        inputField.disabled = false;
        sendBtn.disabled = false;
        inputField.focus();
    }

    function levenshtein(a, b) {
        if(a.length == 0) return b.length; 
        if(b.length == 0) return a.length; 
        var matrix = [];
        var i;
        for(i = 0; i <= b.length; i++){ matrix[i] = [i]; }
        var j;
        for(j = 0; j <= a.length; j++){ matrix[0][j] = j; }
        for(i = 1; i <= b.length; i++){
            for(j = 1; j <= a.length; j++){
                if(b.charAt(i-1) == a.charAt(j-1)){ matrix[i][j] = matrix[i-1][j-1]; } 
                else { matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1)); }
            }
        }
        return matrix[b.length][a.length];
    }

</script>
</body>
</html>
