<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FRANKENSTEIN V4.0 - NEURAL NETWORK</title>
<style>
    /* CSS VARS & BASIC SETUP */
    :root {
        --bg: #0d0d0d;
        --glass: #001100;
        --text: #33ff00;
        --text-dim: #228b00;
        --accent: #9dff80;
        --user: #ffff00;
        --error: #ff3333;
        --border: #1a5c00;
    }

    body {
        background-color: var(--bg);
        color: var(--text);
        font-family: 'Courier New', Courier, monospace;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    /* HEADER */
    header {
        width: 100%;
        background: #000;
        border-bottom: 2px solid var(--text);
        padding: 10px 0;
        text-align: center;
        box-shadow: 0 0 20px rgba(51, 255, 0, 0.2);
    }
    h1 { margin: 0; text-shadow: 0 0 5px var(--text); letter-spacing: 3px; font-size: 1.4rem; }

    /* LAYOUT */
    #container {
        display: flex;
        flex-direction: column;
        width: 95%;
        max-width: 950px;
        height: 90vh;
        margin-top: 15px;
        gap: 15px;
    }

    /* LOG SCREEN */
    #terminal {
        flex-grow: 1;
        border: 1px solid var(--text);
        background: radial-gradient(circle, #051400 0%, #000500 100%);
        padding: 20px;
        overflow-y: auto;
        font-size: 14px;
        box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
        border-radius: 4px;
    }

    /* CUSTOM SCROLLBAR */
    #terminal::-webkit-scrollbar { width: 10px; }
    #terminal::-webkit-scrollbar-thumb { background: var(--text-dim); border: 1px solid #000; }
    #terminal::-webkit-scrollbar-track { background: #000; }

    /* TEXT TYPES */
    .log { margin-bottom: 3px; color: var(--text-dim); font-size: 0.85em; }
    .log-imp { color: #88ff88; margin-bottom: 3px; font-size: 0.85em; border-left: 2px solid var(--text-dim); padding-left: 5px; }
    .ai-speak { 
        color: #fff; 
        background: rgba(51,255,0,0.1);
        border-left: 4px solid var(--text);
        padding: 10px;
        margin: 15px 0;
        font-weight: bold; 
        text-shadow: 0 0 3px var(--accent);
    }
    .user-speak { color: var(--user); margin: 10px 0; padding-left: 10px; font-weight: bold; }
    .err-speak { color: var(--error); }

    /* CONTROLS AREA */
    #control-panel {
        background: #020202;
        border: 1px solid var(--border);
        padding: 15px;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .toggles-row {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        align-items: center;
        border-bottom: 1px dashed var(--border);
        padding-bottom: 10px;
    }

    label { font-size: 0.8em; color: var(--text-dim); display: flex; align-items: center; gap: 5px; cursor: pointer; }
    label:hover { color: var(--text); }
    input[type="checkbox"] { accent-color: var(--text); cursor: pointer; }
    input[type="range"] { accent-color: var(--text); height: 5px; background: #333; }

    /* INPUT ROW */
    #input-row { display: flex; gap: 10px; }
    
    input[type="text"] {
        flex-grow: 1;
        background: #000;
        border: 1px solid var(--text-dim);
        color: var(--text);
        padding: 15px;
        font-family: inherit;
        font-size: 1.1em;
        transition: 0.2s;
    }
    input[type="text"]:focus { outline: none; border-color: var(--text); box-shadow: 0 0 10px var(--border); }

    .btn {
        background: var(--text-dim);
        color: #000;
        border: 1px solid var(--text);
        padding: 0 20px;
        font-weight: bold;
        font-family: inherit;
        cursor: pointer;
        transition: 0.2s;
        text-transform: uppercase;
        font-size: 0.9em;
    }
    .btn:hover { background: var(--text); box-shadow: 0 0 15px var(--text); }
    .btn-api { background: #003300; color: var(--accent); border-color: var(--accent); }
    .btn:disabled { background: #222; border-color: #444; color: #555; cursor: not-allowed; box-shadow: none; }

    #db-status { margin-left: auto; font-size: 0.8em; color: #555; }

</style>
</head>
<body>

    <header>
        <h1>PROJECT FRANKENSTEIN V4.0</h1>
    </header>

    <div id="container">
        
        <div id="terminal">System Online.
Dictionary Matrix: Loaded.
Oxford Uplink: READY.
Safety Protocols: ACTIVE.
--------------------------------------</div>

        <div id="control-panel">
            
            <div class="toggles-row">
                <label title="First word cannot trigger sentence end.">
                    <input type="checkbox" id="chkStartSafe" checked> First Word Immunity
                </label>
                
                <label title="Prevent 'The The' or 'Run Run' patterns.">
                    <input type="checkbox" id="chkLoopSafe" checked> Loop Safety
                </label>

                <label>
                    Min Length: <span id="lenDisplay">2</span>
                    <input type="range" id="sldMinLen" min="1" max="10" value="2" oninput="document.getElementById('lenDisplay').innerText = this.value">
                </label>
                
                <div id="db-status">DB: Calculating...</div>
            </div>

            <div id="input-row">
                <input type="text" id="userInput" placeholder="Awaiting Input..." autocomplete="off">
                <button class="btn btn-api" id="importBtn" onclick="importFromOxford()">IMPORT FROM OXFORD</button>
                <button class="btn" id="sendBtn" onclick="runFrankenstein()">TRANSMIT</button>
            </div>
        </div>
    </div>

<script>
    // =========================================================
    // BRAIN STRUCTURE (Grammar Rules)
    // =========================================================

    // COMPATIBLES TEMPLATE: 
    // This dictates valid next steps. 
    // Crucial: v_link (is) generally doesn't follow v_link.
    const COMPATIBLES_TEMPLATE = {
        n:      ["v_act", "v_link", "con", "pre", "pun", "adv"],
        v_act:  ["n", "pre", "art", "pro", "adv"], // Actions target Nouns (run to..., eat apple...)
        v_link: ["adj", "art", "n"],               // Linking targets Adjectives (is happy) or Articles (is a)
        adj:    ["n", "pun", "con", "pre"], 
        art:    ["n", "adj"], 
        pro:    ["v_act", "v_link", "modal"], 
        pre:    ["n", "art", "pro"], 
        con:    ["pro", "n", "art", "v_act"], 
        adv:    ["v_act", "adj", "pun"],
        modal:  ["v_act", "v_link", "pro"],
        greet:  ["pun", "pro", "n"],
        pun:    ["end", "start"] 
    };

    // THE DATABASE
    // New Feature: "endings" affects future grammar.
    // If ending includes 're (you're), we dynamically shift the next check to expect Linked objects, not new verbs.
    
    const DICTIONARY = {
        // --- SYSTEM ---
        "start_token": { pos: "start", tags: [], endings: [] },

        // --- GREETINGS ---
        "hello": { pos: "greet", tags: ["greeting", "friendly"], endings: [] },
        "hi":    { pos: "greet", tags: ["greeting", "casual"], endings: [] },
        
        // --- PRONOUNS ---
        "i":   { pos: "pro", tags: ["self", "identity"], endings: ["'m", "'ve"] },
        "you": { pos: "pro", tags: ["user", "human"], endings: ["'re", "'ve"] },
        "it":  { pos: "pro", tags: ["object"], endings: ["'s"] },
        "we":  { pos: "pro", tags: ["group"], endings: ["'re"] },
        "he":  { pos: "pro", tags: ["living"], endings: ["'s"] },
        "she": { pos: "pro", tags: ["living"], endings: ["'s"] },

        // --- MODALS / HELPERS ---
        "can":  { pos: "modal", tags: ["question", "ability"], endings: ["'t"] },
        "do":   { pos: "modal", tags: ["action"], endings: ["n't", "ing"] }, // Doing becomes noun-ish/verb-ish
        "will": { pos: "modal", tags: ["future"], endings: ["'t"] },

        // --- NOUNS ---
        "monster": { pos: "n", tags: ["self", "scary", "science"], endings: ["s"] },
        "human":   { pos: "n", tags: ["user", "biology"], endings: ["s"] },
        "brain":   { pos: "n", tags: ["science", "thought", "biology"], endings: ["s"] },
        "tornado": { pos: "n", tags: ["weather", "disaster", "danger"], endings: ["s"] },
        "storm":   { pos: "n", tags: ["weather", "loud"], endings: ["s"] },
        "sun":     { pos: "n", tags: ["weather", "fire", "light"], endings: ["s"] },
        "fire":    { pos: "n", tags: ["element", "hot", "danger"], endings: ["place"] },
        "water":   { pos: "n", tags: ["element", "wet", "life"], endings: ["s"] },
        "cat":     { pos: "n", tags: ["animal", "soft"], endings: ["s"] },
        "fear":    { pos: "n", tags: ["emotion", "scary"], endings: [] }, // can be noun "The fear"
        "love":    { pos: "n", tags: ["emotion", "good"], endings: [] }, // or verb

        // --- VERBS (LINKING vs ACTION) ---
        "is":  { pos: "v_link", tags: ["exist", "state"], endings: ["n't"] },
        "am":  { pos: "v_link", tags: ["exist", "self"], endings: [] },
        "are": { pos: "v_link", tags: ["exist", "plural"], endings: ["n't"] },
        
        "run":  { pos: "v_act", tags: ["action", "fast"], endings: ["s", "ning"] },
        "eat":  { pos: "v_act", tags: ["action", "biology"], endings: ["s", "ing"] },
        "see":  { pos: "v_act", tags: ["sense", "vision"], endings: ["s", "ing"] },
        "make": { pos: "v_act", tags: ["action", "create"], endings: ["s", "ing"] },
        "break":{ pos: "v_act", tags: ["action", "bad"], endings: ["s", "ing"] },
        "think":{ pos: "v_act", tags: ["thought", "mind"], endings: ["s", "ing"] },
        
        // --- ADJECTIVES ---
        "happy":    { pos: "adj", tags: ["emotion", "good"], endings: [] },
        "sad":      { pos: "adj", tags: ["emotion", "bad"], endings: [] },
        "scary":    { pos: "adj", tags: ["fear", "bad"], endings: [] },
        "alive":    { pos: "adj", tags: ["biology", "state"], endings: [] },
        "dangerous":{ pos: "adj", tags: ["danger", "caution"], endings: [] },
        "big":      { pos: "adj", tags: ["size", "physical"], endings: [] },
        "red":      { pos: "adj", tags: ["color", "blood", "fire"], endings: [] },

        // --- OTHERS ---
        "the": { pos: "art", tags: ["specific"], endings: [] },
        "a":   { pos: "art", tags: ["general"], endings: [] },
        "my":  { pos: "art", tags: ["possession"], endings: [] },
        "and": { pos: "con", tags: ["logic"], endings: [] },
        "but": { pos: "con", tags: ["logic"], endings: [] },
        "to":  { pos: "pre", tags: ["direction"], endings: [] },
        "in":  { pos: "pre", tags: ["location"], endings: [] },
        
        // --- PUNCTUATION (With 'comp' override) ---
        ".": { pos: "pun", tags: ["end"], endings: [], comp: ["end"] },
        "!": { pos: "pun", tags: ["end"], endings: [], comp: ["end"] },
        "?": { pos: "pun", tags: ["end"], endings: [], comp: ["end"] },
        ",": { pos: "pun", tags: ["pause"], endings: [], comp: ["pro", "art", "n", "v_act", "con"] }
    };

    updateDBStatus();

    // =========================================================
    // SYSTEM UI LOGIC
    // =========================================================
    const term = document.getElementById('terminal');
    const inp = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const impBtn = document.getElementById('importBtn');

    // Controls
    const chkStart = document.getElementById('chkStartSafe');
    const chkLoop = document.getElementById('chkLoopSafe');
    const sldLen = document.getElementById('sldMinLen');

    function log(text, type='log') {
        const div = document.createElement('div');
        div.className = type;
        div.innerText = text;
        term.appendChild(div);
        term.scrollTop = term.scrollHeight;
    }

    function updateDBStatus() {
        document.getElementById('db-status').innerText = `MemBank: ${Object.keys(DICTIONARY).length} Words`;
    }

    // =========================================================
    // THE OXFORD UPLINK (Import Function)
    // =========================================================
    async function importFromOxford() {
        // 1. Get input
        const rawInput = prompt("ENTER WORD DATA TO ASSIMILATE:");
        if(!rawInput) return;
        const targetWord = rawInput.trim().toLowerCase();

        // Check duplicates
        if(DICTIONARY[targetWord]) {
            log(`[IMP] ERROR: Word '${targetWord}' already exists in Memory Bank.`, 'err-speak');
            return;
        }

        log(`[IMP] INITIATING OXFORD PROTOCOL FOR: '${targetWord}'...`, 'log-imp');
        impBtn.disabled = true;

        try {
            // 2. FETCH from dictionaryapi.dev (Open, CORS friendly)
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${targetWord}`);
            if(!response.ok) throw new Error("Data not found");
            
            const data = await response.json();
            const firstDef = data[0].meanings[0];
            const apiPOS = firstDef.partOfSpeech;
            const defText = firstDef.definitions[0].definition;

            log(`[IMP] UPLINK SUCCESS. POS: ${apiPOS}`, 'log-imp');
            log(`[IMP] ANALYZING DEFINITION: "${defText}"`, 'log-imp');

            // 3. ANALYZE DEFINITION (The Frankenstein Logic)
            // Use existing logic to find tags in the definition text
            const newTags = new Set();
            const defWords = defText.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/);
            
            defWords.forEach(dw => {
                const low = dw.toLowerCase();
                // Check direct tag existence
                if(DICTIONARY[low]) {
                    DICTIONARY[low].tags.forEach(t => newTags.add(t));
                } else {
                    // Fuzzy tag check
                    Object.keys(DICTIONARY).forEach(k => {
                         if(levenshtein(low, k) < 3) {
                             DICTIONARY[k].tags.forEach(t => newTags.add(t));
                         }
                    });
                }
            });

            // Fallback tags if Definition was vague
            if(newTags.size === 0) newTags.add("concept");
            newTags.add("imported");

            // 4. MAP API POS TO SYSTEM POS
            let systemPOS = "n"; // default
            if(apiPOS === "noun") systemPOS = "n";
            else if(apiPOS === "verb") systemPOS = "v_act"; // assume action, hard to detect linking remotely
            else if(apiPOS === "adjective") systemPOS = "adj";
            else if(apiPOS === "adverb") systemPOS = "adv";
            else if(apiPOS === "preposition") systemPOS = "pre";

            // 5. INJECT INTO BRAIN
            DICTIONARY[targetWord] = {
                pos: systemPOS,
                tags: Array.from(newTags),
                endings: ["s"] // Default ending capacity
            };

            log(`[IMP] ASSIMILATION COMPLETE. New Node: ${targetWord} [${systemPOS}] tags:[${Array.from(newTags)}]`, 'log-imp');
            updateDBStatus();

        } catch(e) {
            log(`[IMP] UPLINK FAILED: ${e.message}`, 'err-speak');
        } finally {
            impBtn.disabled = false;
        }
    }

    // =========================================================
    // CORE GENERATOR
    // =========================================================
    function runFrankenstein() {
        const query = inp.value.trim().toLowerCase();
        if(!query) return;

        inp.value = "";
        inp.disabled = true; sendBtn.disabled = true; impBtn.disabled = true;

        log(`USER: ${query}`, 'user-speak');
        log("Thinking...", "log");

        // 1. EXTRACT CONTEXT (Levenshtein based)
        const ctxTags = new Set();
        const inputTokens = query.replace(/[.,?!]/g,"").split(/\s+/);

        inputTokens.forEach(t => {
            // Find in dictionary (Fuzzy)
            let match = null;
            let bestD = 3; 

            Object.keys(DICTIONARY).forEach(dbWord => {
                const dist = levenshtein(t, dbWord);
                if(dist <= 2 && dist < bestD) { 
                    match = dbWord; bestD = dist; 
                }
            });
            // If match found, grab tags
            if(match) {
                log(` Identified concept: ${match}`, 'log');
                DICTIONARY[match].tags.forEach(x => ctxTags.add(x));
            } else if (DICTIONARY[t]) {
                DICTIONARY[t].tags.forEach(x => ctxTags.add(x));
            }
        });

        // 2. GENERATE
        let sequence = [];
        let prevWordEntry = DICTIONARY["start_token"];
        
        // Loop State
        const MAX_STEPS = 20;
        let step = 0;
        const targetLen = parseInt(sldLen.value);

        const generateStep = () => {
            if (step >= MAX_STEPS) { finish(sequence); return; }

            // -- DETERMINE COMPATIBILITY --
            // Default check from template
            let allowed = [];
            
            // Check Overrides first
            if(prevWordEntry.comp) {
                allowed = prevWordEntry.comp;
            } else {
                allowed = COMPATIBLES_TEMPLATE[prevWordEntry.pos] || ["n"];
            }

            // *** PREVENT "I've Is" (Grammar Patch) ***
            // We check the specific sequence ending of the LAST generated word.
            if (sequence.length > 0) {
                const lastString = sequence[sequence.length-1];
                // Check if last string implies a "Hidden Verb" (Contraction)
                if (lastString.endsWith("'m") || lastString.endsWith("'re") || lastString.endsWith("'s") || lastString.endsWith("'ve")) {
                     log(`..detected contraction in [${lastString}] - Altering logic path..`, 'log');
                     // If we just said "You're" (You are), we basically just said a Linking Verb.
                     // The valid followers of a Linking Verb are Adj, Art, Noun. NOT another Link.
                     // We FORCE the valid next list to act as if prev was "v_link"
                     allowed = COMPATIBLES_TEMPLATE["v_link"];
                }
                // Special check: If we end with "doing" (ing), usually implies active.
                if (lastString.endsWith("ing")) {
                    allowed = ["n", "pre", "adv"]; // Doing something
                }
            }

            // Filter out end/punctuation if too short
            if(step < targetLen || (chkStart.checked && step === 0)) {
                allowed = allowed.filter(p => p !== 'pun' && p !== 'end');
            }

            // -- SCORE CANDIDATES --
            let candidates = [];
            Object.keys(DICTIONARY).forEach(key => {
                if(key === "start_token") return;
                const entry = DICTIONARY[key];
                
                if(allowed.includes(entry.pos)) {
                    
                    // Loop Safety Check
                    if (chkLoop.checked) {
                        if (sequence.includes(key)) return; // basic strict duplicate prevention
                    }

                    let score = 0;

                    // Score A: Context
                    const hasTag = entry.tags.some(t => ctxTags.has(t));
                    if(hasTag) score += 20;

                    // Score B: Fuzzy input match
                    inputTokens.forEach(token => {
                         if(levenshtein(key, token) < 3) score += 5;
                    });

                    // Score C: Ending urging
                    if(entry.pos === "pun" && step > targetLen + 2) score += 25;

                    // Score D: Greeting Spam Prevention
                    if(entry.pos === "greet" && step > 0) score -= 100;

                    // Score E: State vs Action Balance
                    if(entry.pos === "v_link" && prevWordEntry.pos === "pro") score += 5; // I am > I run (statistically more common starter)

                    candidates.push({ k: key, s: score, e: entry });
                }
            });

            // Dead end logic
            if(candidates.length === 0) {
                candidates.push({ k: ".", s: 999, e: DICTIONARY["."] });
            }

            // Pick
            candidates.sort((a,b) => b.s - a.s + (Math.random()*4 - 2));
            let winner = candidates[0];

            // -- MUTATION (Ending application) --
            // If the Winner is 'do', let's maybe make it 'doing' or 'don't'
            let finalStr = winner.k;
            const validEndings = winner.e.endings;

            // Only mutate if NOT punctuation and NOT "start"
            if (winner.e.pos !== 'pun' && validEndings && validEndings.length > 0) {
                // 30% chance to mutate
                if(Math.random() < 0.3) {
                    const suffix = validEndings[Math.floor(Math.random() * validEndings.length)];
                    // Grammar safety: Don't double suffix
                    finalStr = winner.k + suffix;
                }
            }

            // Final check: Punctuation End
            if(winner.e.tags.includes("end") && step >= targetLen) {
                sequence.push(finalStr);
                finish(sequence);
                return;
            }

            // Push and Continue
            sequence.push(finalStr);
            prevWordEntry = winner.e; // Store BASE entry, but remember logic checks string ending above
            step++;
            setTimeout(generateStep, 250 + Math.random()*200);
        };

        generateStep();
    }

    function finish(seq) {
        // Construct string (One Capital at start)
        let str = "";
        seq.forEach((w, i) => {
            let frag = w;
            if(i === 0) frag = w.charAt(0).toUpperCase() + w.slice(1);
            
            if(DICTIONARY[w] && DICTIONARY[w].pos === 'pun') {
                str += frag; // attach punct
            } else if (i > 0) {
                str += " " + frag;
            } else {
                str += frag;
            }
        });

        log(`FRANKENSTEIN: ${str}`, 'ai-speak');
        
        inp.disabled = false; sendBtn.disabled = false; impBtn.disabled = false;
        inp.focus();
    }

    // Levenshtein Math
    function levenshtein(a, b) {
        if(!a || !b) return 99;
        const m = [];
        for(let i=0; i<=b.length; i++) m[i] = [i];
        for(let j=0; j<=a.length; j++) m[0][j] = j;
        for(let i=1; i<=b.length; i++){
            for(let j=1; j<=a.length; j++){
                const c = (b.charAt(i-1) === a.charAt(j-1)) ? 0 : 1;
                m[i][j] = Math.min(m[i-1][j-1]+c, m[i][j-1]+1, m[i-1][j]+1);
            }
        }
        return m[b.length][a.length];
    }

</script>
</body>
</html>
