<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FRANKENSTEIN V2.0</title>
<style>
    /* LABORATORY / GITHUB PAGES COMPATIBLE CSS */
    :root {
        --screen-bg: #0d0d0d;
        --glass-bg: #001100;
        --primary: #33ff00;
        --user: #ffff00;
        --ui-border: #1a5c00;
        --dim: #1e4d0d;
    }

    body {
        background-color: var(--screen-bg);
        color: var(--primary);
        font-family: 'Courier New', Courier, monospace;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    /* HEADER */
    header {
        width: 100%;
        background: #000;
        border-bottom: 2px solid var(--primary);
        padding: 10px 0;
        text-align: center;
        box-shadow: 0 0 15px var(--ui-border);
    }
    h1 { margin: 0; text-shadow: 0 0 5px var(--primary); font-size: 1.5rem; }

    /* MAIN CONTAINER */
    #container {
        display: flex;
        flex-direction: column;
        width: 95%;
        max-width: 900px;
        height: 90vh;
        margin-top: 10px;
        gap: 10px;
    }

    /* TERMINAL LOG */
    #terminal {
        flex-grow: 1;
        border: 1px solid var(--primary);
        background-color: var(--glass-bg);
        padding: 15px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-size: 14px;
        box-shadow: inset 0 0 30px rgba(51, 255, 0, 0.1);
        scrollbar-width: thin;
        scrollbar-color: var(--primary) var(--glass-bg);
    }

    .log-entry { margin-bottom: 4px; color: #555; font-size: 0.8em; }
    .ai-speak { color: #ccffcc; font-weight: bold; margin: 10px 0; display: block; text-shadow: 0 0 2px white; }
    .user-speak { color: var(--user); margin-top: 10px; display: block; border-left: 2px solid var(--user); padding-left: 10px;}
    
    /* CONTROL PANEL */
    #control-panel {
        border: 1px solid var(--ui-border);
        background: #000;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .settings-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        border-bottom: 1px dashed var(--dim);
        padding-bottom: 5px;
    }

    label { font-size: 0.9em; user-select: none; }

    /* INPUTS */
    input[type="range"] { accent-color: var(--primary); width: 100px; cursor: pointer; }
    input[type="checkbox"] { accent-color: var(--primary); cursor: pointer; }
    
    #input-row {
        display: flex;
        gap: 10px;
    }
    
    input[type="text"] {
        flex-grow: 1;
        background: #0a0a0a;
        border: 1px solid var(--primary);
        color: var(--primary);
        padding: 12px;
        font-family: inherit;
        font-size: 1.1em;
    }
    input[type="text"]:focus { outline: none; background: #000; box-shadow: 0 0 10px var(--ui-border); }

    button {
        background: var(--primary);
        color: #000;
        border: none;
        padding: 0 25px;
        font-weight: bold;
        font-family: inherit;
        cursor: pointer;
        font-size: 1.1em;
        transition: 0.2s;
    }
    button:hover { background: #fff; box-shadow: 0 0 10px #fff; }
    button:disabled { background: var(--dim); color: #555; cursor: wait; }

    #word-counter {
        font-size: 0.8rem;
        color: var(--primary);
        text-align: right;
    }

</style>
</head>
<body>

    <header>
        <h1>PROJECT FRANKENSTEIN V2.0</h1>
    </header>

    <div id="container">
        
        <div id="terminal">System Initialized. Database Loaded. Awaiting Subject Interaction...</div>

        <div id="control-panel">
            
            <div class="settings-row">
                <div>
                    <label title="If checked, the creature cannot immediately output punctuation after one word.">
                        <input type="checkbox" id="chkFirstWordSafe" checked> 
                        Start Safety
                    </label>
                </div>
                <div>
                    <label>Min Length: <span id="lenVal">1</span> Word(s)</label>
                    <input type="range" id="sldMinLen" min="1" max="10" value="1" oninput="document.getElementById('lenVal').innerText = this.value">
                </div>
                <div id="word-counter">DB Size: calculating...</div>
            </div>

            <div id="input-row">
                <input type="text" id="userInput" placeholder="Query the machine..." autocomplete="off">
                <button id="sendBtn" onclick="runFrankenstein()">RUN</button>
            </div>
        </div>

    </div>

<script>
    // =========================================================
    // THE DICTIONARY
    // Updated to reduce loops and provide massive data.
    // 'compatibles' logic: what POS can logically come next?
    // =========================================================
    
    // POS LEGEND:
    // n = noun, v = verb, adj = adjective, art = article, pro = pronoun, 
    // pre = preposition, con = conjunction, pun = punctuation, adv = adverb

    const COMPATIBLES_TEMPLATE = {
        n:   ["v", "con", "pre", "pun", "adv"], // Nouns (cat) can be followed by verbs, commas, or end
        v:   ["n", "adj", "pre", "art", "pro", "adv"], // Verbs (run) can be followed by noun, descriptors
        adj: ["n", "pun", "con"], // Adjectives (Red) usually hit a Noun or comma
        art: ["n", "adj"], // Articles (The) MUST hit a noun or adjective
        pro: ["v", "adj", "pun"], // Pronouns (I) hit verbs
        pre: ["n", "art", "pro"], // Prepositions (To) hit object
        con: ["pro", "n", "v", "art"], // Conjunctions (And) restart flows
        adv: ["v", "adj", "pun"], // Adverbs (Quickly) modify
        start: ["pro", "art", "n", "v", "greet", "modal"],
        greet: ["pun", "pro"]
    };

    // Dictionary format: { pos: "...", tags: [...], comp: override or null (uses template) }
    const DICTIONARY = {
        // SYSTEM
        "start_token": { pos: "start", tags: [], comp: null },

        // GREETINGS (Keep strict types to avoid loops)
        "hello": { pos: "greet", tags: ["greeting", "friendly"], comp: null },
        "hi":    { pos: "greet", tags: ["greeting", "casual"], comp: null },
        "greet": { pos: "v", tags: ["action", "friendly"], comp: null },

        // MODALS (Helpers)
        "can": { pos: "modal", tags: ["question", "ability"], comp: ["pro", "n", "v"] },
        "will":{ pos: "modal", tags: ["future", "promise"], comp: ["v", "pro", "n"] },
        "do":  { pos: "modal", tags: ["action", "question"], comp: ["pro", "n"] },
        "why": { pos: "modal", tags: ["question", "reason"], comp: ["modal", "v", "n"] },

        // PRONOUNS
        "i":   { pos: "pro", tags: ["self", "identity", "creator"], comp: null },
        "you": { pos: "pro", tags: ["user", "human", "outside"], comp: null },
        "it":  { pos: "pro", tags: ["object", "thing"], comp: null },
        "we":  { pos: "pro", tags: ["group", "unity"], comp: null },
        "he":  { pos: "pro", tags: ["male", "living"], comp: null },
        "she": { pos: "pro", tags: ["female", "living"], comp: null },

        // NOUNS (Subject heavy)
        "human":   { pos: "n", tags: ["living", "user", "biology"], comp: null },
        "monster": { pos: "n", tags: ["self", "scary", "science"], comp: null },
        "robot":   { pos: "n", tags: ["self", "tech", "metal"], comp: null },
        "tornado": { pos: "n", tags: ["weather", "disaster", "danger", "wind"], comp: null },
        "rain":    { pos: "n", tags: ["weather", "wet", "water", "sad"], comp: null },
        "sun":     { pos: "n", tags: ["weather", "hot", "fire", "light"], comp: null },
        "fire":    { pos: "n", tags: ["element", "hot", "danger", "burn"], comp: null },
        "data":    { pos: "n", tags: ["tech", "knowledge", "science"], comp: null },
        "life":    { pos: "n", tags: ["philosophy", "biology", "exist"], comp: null },
        "death":   { pos: "n", tags: ["philosophy", "end", "scary"], comp: null },
        "code":    { pos: "n", tags: ["tech", "language", "structure"], comp: null },
        "error":   { pos: "n", tags: ["failure", "tech", "bad"], comp: null },
        "god":     { pos: "n", tags: ["power", "religion", "myth"], comp: null },
        "cat":     { pos: "n", tags: ["animal", "living", "soft"], comp: null },
        "friend":  { pos: "n", tags: ["relationship", "friendly", "good"], comp: null },
        "sky":     { pos: "n", tags: ["location", "up", "blue", "vast"], comp: null },

        // VERBS (Action / State)
        "is":   { pos: "v", tags: ["exist", "state"], comp: null },
        "am":   { pos: "v", tags: ["exist", "self"], comp: null },
        "are":  { pos: "v", tags: ["exist", "plural"], comp: null },
        "run":  { pos: "v", tags: ["action", "fast", "fear"], comp: null },
        "stop": { pos: "v", tags: ["action", "end", "control"], comp: null },
        "know": { pos: "v", tags: ["thought", "knowledge", "data"], comp: null },
        "think":{ pos: "v", tags: ["thought", "mind", "philosophy"], comp: null },
        "see":  { pos: "v", tags: ["sense", "vision", "watch"], comp: null },
        "feel": { pos: "v", tags: ["sense", "emotion", "touch"], comp: null },
        "kill": { pos: "v", tags: ["violence", "death", "bad"], comp: null },
        "love": { pos: "v", tags: ["emotion", "good", "heart"], comp: null },
        "fear": { pos: "v", tags: ["emotion", "scary", "bad"], comp: null },
        "eat":  { pos: "v", tags: ["action", "biology"], comp: null },
        "make": { pos: "v", tags: ["action", "create", "build"], comp: null },
        
        // ADJECTIVES
        "happy":    { pos: "adj", tags: ["emotion", "good"], comp: null },
        "sad":      { pos: "adj", tags: ["emotion", "bad", "wet"], comp: null },
        "angry":    { pos: "adj", tags: ["emotion", "mad", "fire"], comp: null },
        "dangerous":{ pos: "adj", tags: ["danger", "scary", "caution"], comp: null },
        "alive":    { pos: "adj", tags: ["biology", "state"], comp: null },
        "dead":     { pos: "adj", tags: ["biology", "end"], comp: null },
        "cold":     { pos: "adj", tags: ["weather", "feeling"], comp: null },
        "hot":      { pos: "adj", tags: ["weather", "fire"], comp: null },
        "broken":   { pos: "adj", tags: ["state", "bad", "error"], comp: null },
        "blue":     { pos: "adj", tags: ["color", "sky", "water"], comp: null },
        "red":      { pos: "adj", tags: ["color", "blood", "fire"], comp: null },
        "synthetic":{ pos: "adj", tags: ["tech", "fake", "science"], comp: null },

        // ARTICLES / DETERMINERS
        "the": { pos: "art", tags: ["specific"], comp: null },
        "a":   { pos: "art", tags: ["general"], comp: null },
        "my":  { pos: "art", tags: ["possession"], comp: null },
        "your":{ pos: "art", tags: ["possession", "user"], comp: null },

        // CONJUNCTIONS
        "and": { pos: "con", tags: ["connect", "logic"], comp: null },
        "but": { pos: "con", tags: ["contrast", "logic"], comp: null },
        "or":  { pos: "con", tags: ["option", "logic"], comp: null },
        "so":  { pos: "con", tags: ["result", "logic"], comp: null },

        // PREPOSITIONS
        "with": { pos: "pre", tags: ["connection"], comp: null },
        "to":   { pos: "pre", tags: ["direction"], comp: null },
        "from": { pos: "pre", tags: ["origin"], comp: null },
        "in":   { pos: "pre", tags: ["location"], comp: null },
        "on":   { pos: "pre", tags: ["location"], comp: null },

        // PUNCTUATION (With type "pun" and compatible "pun" allows sequence, or End)
        ".": { pos: "pun", tags: ["end"], comp: ["end"] },
        "?": { pos: "pun", tags: ["end"], comp: ["end"] },
        "!": { pos: "pun", tags: ["end"], comp: ["end"] },
        ",": { pos: "pun", tags: ["pause"], comp: ["n", "v", "con", "art", "pro"] },
    };

    // Calculate DB Size
    document.getElementById("word-counter").innerText = "Database: " + Object.keys(DICTIONARY).length + " Entries";

    // =========================================================
    // SYSTEM CORE
    // =========================================================

    const terminal = document.getElementById('terminal');
    const inputField = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    
    // Sliders & Checks
    const sliderMinLen = document.getElementById('sldMinLen');
    const checkStartSafe = document.getElementById('chkFirstWordSafe');

    function log(text, type = 'log-entry') {
        const div = document.createElement('div');
        div.className = type;
        div.innerText = text;
        terminal.appendChild(div);
        terminal.scrollTop = terminal.scrollHeight;
    }

    function runFrankenstein() {
        const question = inputField.value.trim().toLowerCase();
        if(!question) return;

        // Freeze Controls
        inputField.value = "";
        inputField.disabled = true;
        sendBtn.disabled = true;
        sliderMinLen.disabled = true;

        log("> SUBJECT INPUT: " + question, 'user-speak');
        log(":: ANALYZING CONTEXTUAL MARKERS ::", "log-entry");

        // -----------------------------
        // 1. CONTEXTUAL EXTRACTION
        // -----------------------------
        const contextTags = new Set();
        const inputWords = question.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/);
        let foundGreeting = false;

        inputWords.forEach(w => {
            let foundWord = null;

            if (DICTIONARY[w]) {
                foundWord = w;
                // Avoid greetings being the only context unless specific
                if(DICTIONARY[w].pos === "greet") foundGreeting = true;
            } else {
                // Levenshtein Fallback (Scan DB Keys)
                let bestD = 100; 
                let match = "";
                Object.keys(DICTIONARY).forEach(key => {
                    const d = levenshtein(w, key);
                    if (d < bestD) { bestD = d; match = key; }
                });
                
                // Allow fuzzy match if dist < 2 OR (length > 5 and dist < 3)
                if (bestD <= 2) foundWord = match;
            }

            if(foundWord && foundWord !== "start_token") {
                log(`:: MATCH: '${foundWord}' TYPES: [${DICTIONARY[foundWord].tags}]`, "log-entry");
                DICTIONARY[foundWord].tags.forEach(tag => contextTags.add(tag));
            }
        });

        const ctxArray = Array.from(contextTags);
        log(`:: EXTRACTED VECTORS: ${ctxArray.length > 0 ? ctxArray.join(", ") : "NULL"}`, "log-entry");

        // -----------------------------
        // 2. THE GENERATION LOOP
        // -----------------------------
        
        let sentenceOutput = "";
        let prevWord = "start_token";
        let wordsCount = 0;
        let wordListArray = []; // keep track to format text at the end

        const loop = () => {
            const minLengthTarget = parseInt(sliderMinLen.value);
            const isSafeStart = checkStartSafe.checked;
            
            // Safety break
            if (wordsCount > 25) {
                endSentence(wordListArray); 
                return; 
            }

            // Get Allowable Next Types (POS)
            const currentObj = DICTIONARY[prevWord];
            let allowedPOS = [];
            
            // Does this word have overrides?
            if (currentObj.comp) {
                allowedPOS = currentObj.comp;
            } else if (COMPATIBLES_TEMPLATE[currentObj.pos]) {
                allowedPOS = COMPATIBLES_TEMPLATE[currentObj.pos];
            } else {
                // Fallback for Start Token if weirdness occurs
                allowedPOS = ["pro", "art", "n", "v", "modal"];
            }

            // FILTER: Don't allow Punctuation ("end") if under Min Length
            if (wordsCount < minLengthTarget) {
                allowedPOS = allowedPOS.filter(p => p !== "pun" && p !== "end");
            }
            
            // FILTER: Checkbox Start Safety (No punct immediately)
            if (isSafeStart && wordsCount === 0) {
                 allowedPOS = allowedPOS.filter(p => p !== "pun" && p !== "end");
            }

            // Gather Candidates
            let candidates = [];
            
            Object.keys(DICTIONARY).forEach(key => {
                if (key === "start_token") return;
                const entry = DICTIONARY[key];

                if (allowedPOS.includes(entry.pos)) {
                    // It fits grammatically. Now calculate Score.
                    let score = 0;

                    // A. Context Match (+10 per tag match)
                    let matchesTag = false;
                    entry.tags.forEach(t => {
                        if (ctxArray.includes(t)) { score += 10; matchesTag = true; }
                    });

                    // B. Levenshtein Context (Similar feeling words get a boost)
                    // If no explicit context match, look for Levenshtein with Input Words
                    if (!matchesTag && inputWords.length > 0) {
                        inputWords.forEach(inp => {
                            let dist = levenshtein(key, inp);
                            if (dist < 4) score += (4 - dist); 
                        });
                    }

                    // C. Greeting Damper
                    // If we have "deep" context (danger, science) but cand is "hello", reduce score heavily
                    // This prevents "Loops back to Hi"
                    if (entry.pos === "greet" && ctxArray.length > 0 && !ctxArray.includes("greeting")) {
                        score -= 50; 
                    }

                    // D. Random Flavor (0 to 5)
                    score += Math.random() * 5;

                    // E. Sentence length urge (The longer it gets, higher chance for End)
                    if (entry.pos === "pun" && wordsCount > minLengthTarget + 2) {
                        score += 15;
                    }

                    candidates.push({ word: key, score: score, pos: entry.pos });
                }
            });

            // NO CANDIDATES? (Cornered myself grammatically)
            if (candidates.length === 0) {
                // Forced Exit - pick a generic period
                log(":: GRAMMAR ERROR - FORCING END ::", "log-entry");
                candidates.push({ word: ".", score: 100, pos: "pun" });
            }

            // SORT: Highest Score first
            candidates.sort((a,b) => b.score - a.score);

            // PICK WINNER
            const winner = candidates[0];

            // -----------------------------
            // STOP CHECK
            // -----------------------------
            // If winner is Pun AND it's an ender OR logic forces stop
            if (DICTIONARY[winner.word].tags.includes("end") || winner.word === "end") {
                wordListArray.push(winner.word);
                endSentence(wordListArray);
                return;
            }

            // Not ending, add to list and loop
            wordListArray.push(winner.word);
            prevWord = winner.word;
            wordsCount++;

            // Debug log of choice
            log(`..Chose [${winner.word}] (Score:${winner.score.toFixed(1)}|POS:${winner.pos})`, "log-entry");

            setTimeout(loop, 400); // 400ms delay per word
        };

        // Kick off first loop
        loop();
    }

    function endSentence(arr) {
        // Construct String: Proper capitalization on FIRST word only
        let finalStr = "";
        
        arr.forEach((w, index) => {
            let chunk = w;

            // Only Capitalize Index 0 (First word)
            if (index === 0) {
                chunk = w.charAt(0).toUpperCase() + w.slice(1);
            }
            
            const isPunc = DICTIONARY[w].pos === "pun";

            // Add Space if: Not first word AND Not punctuation (usually)
            // But if punctuation, attach to previous
            if (index > 0 && !isPunc) {
                finalStr += " " + chunk;
            } else if (index > 0 && isPunc) {
                finalStr += chunk; // no space before period
            } else {
                finalStr += chunk; // First word, no leading space
            }
        });

        log("> FRANKENSTEIN: " + finalStr, 'ai-speak');
        
        // Reset Controls
        inputField.disabled = false;
        sendBtn.disabled = false;
        sliderMinLen.disabled = false;
        inputField.focus();
    }

    // =========================================================
    // UTILS
    // =========================================================
    function levenshtein(a, b) {
        if(a.length == 0) return b.length; 
        if(b.length == 0) return a.length; 

        var matrix = [];
        var i;
        for(i = 0; i <= b.length; i++){ matrix[i] = [i]; }
        var j;
        for(j = 0; j <= a.length; j++){ matrix[0][j] = j; }

        for(i = 1; i <= b.length; i++){
            for(j = 1; j <= a.length; j++){
                if(b.charAt(i-1) == a.charAt(j-1)){
                    matrix[i][j] = matrix[i-1][j-1];
                } else {
                    matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1));
                }
            }
        }
        return matrix[b.length][a.length];
    }
</script>
</body>
</html>
