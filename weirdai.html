<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Project FRANKENSTEIN</title>
<style>
    /* LABORATORY AESTHETIC CSS */
    body {
        background-color: #0d0d0d;
        color: #33ff00;
        font-family: 'Courier New', Courier, monospace;
        padding: 20px;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    h1 {
        text-shadow: 0 0 5px #33ff00;
        border-bottom: 2px dashed #33ff00;
        width: 100%;
        text-align: center;
        padding-bottom: 10px;
    }

    #terminal {
        width: 90%;
        max-width: 800px;
        height: 60vh;
        border: 2px solid #33ff00;
        background-color: #001100;
        padding: 10px;
        overflow-y: auto;
        margin-bottom: 20px;
        white-space: pre-wrap;
        box-shadow: inset 0 0 20px rgba(51, 255, 0, 0.2);
    }

    .log-entry { margin-bottom: 5px; opacity: 0.8; font-size: 0.9em; }
    .ai-speak { color: #ccffcc; font-weight: bold; text-shadow: 0 0 2px #fff; }
    .user-speak { color: #ffff00; }
    .debug-text { color: #555; font-size: 0.7em; }

    #controls {
        width: 90%;
        max-width: 800px;
        display: flex;
        gap: 10px;
    }

    input {
        flex-grow: 1;
        background: #000;
        border: 1px solid #33ff00;
        color: #33ff00;
        padding: 10px;
        font-family: 'Courier New', Courier, monospace;
        font-size: 1.1em;
    }

    button {
        background: #33ff00;
        color: #000;
        border: none;
        padding: 10px 20px;
        font-weight: bold;
        cursor: pointer;
        font-family: 'Courier New', Courier, monospace;
    }

    button:hover { background: #fff; }
    button:disabled { background: #333; color: #555; cursor: not-allowed; }

</style>
</head>
<body>

    <h1>PROJECT FRANKENSTEIN V1.0</h1>
    
    <div id="terminal">System Ready. Dictionary loaded. Waiting for input...</div>

    <div id="controls">
        <input type="text" id="userInput" placeholder="Ask the monster something..." autocomplete="off">
        <button id="sendBtn" onclick="runFrankenstein()">TRANSMIT</button>
    </div>

<script>
    // =========================================================
    // THE DICTIONARY (Edit this to make it smarter)
    // =========================================================
    // Key: The word itself
    // pos: Part of speech
    // usecase: Tags describing the concept (Weather, Danger, Self, etc)
    // compatibles: Arrays of 'pos' that are allowed to follow this word.
    // =========================================================
    
    const DICTIONARY = {
        "start_token": { pos: "START", usecase: [], compatibles: ["pronoun", "noun", "article", "greeting"] },
        
        // --- Greetings / Basics ---
        "hello": { pos: "greeting", usecase: ["greeting", "friendly"], compatibles: ["punctuation"] },
        "hi": { pos: "greeting", usecase: ["greeting", "friendly"], compatibles: ["punctuation"] },

        // --- Pronouns ---
        "i":   { pos: "pronoun", usecase: ["self", "identity"], compatibles: ["verb"] },
        "you": { pos: "pronoun", usecase: ["user", "human"], compatibles: ["verb", "adjective"] },
        "it":  { pos: "pronoun", usecase: ["object", "generic"], compatibles: ["verb"] },

        // --- Verbs ---
        "am":   { pos: "verb", usecase: ["exist", "state"], compatibles: ["adjective", "noun"] },
        "is":   { pos: "verb", usecase: ["exist", "state"], compatibles: ["adjective", "noun", "article"] },
        "are":  { pos: "verb", usecase: ["exist", "state"], compatibles: ["adjective", "noun"] },
        "run":  { pos: "verb", usecase: ["action", "fast", "move"], compatibles: ["adverb", "preposition"] },
        "eat":  { pos: "verb", usecase: ["action", "hunger"], compatibles: ["noun"] },
        "fear": { pos: "verb", usecase: ["emotion", "danger", "disaster"], compatibles: ["noun"] },
        "love": { pos: "verb", usecase: ["emotion", "friendly"], compatibles: ["noun", "pronoun"] },

        // --- Articles ---
        "the": { pos: "article", usecase: ["specific"], compatibles: ["noun", "adjective"] },
        "a":   { pos: "article", usecase: ["general"], compatibles: ["noun", "adjective"] },

        // --- Nouns (The user specific ones) ---
        "tornado": { pos: "noun", usecase: ["weather", "disaster", "danger"], compatibles: ["verb", "punctuation"] },
        "rain":    { pos: "noun", usecase: ["weather", "wet"], compatibles: ["verb", "punctuation"] },
        "cat":     { pos: "noun", usecase: ["animal", "living"], compatibles: ["verb", "punctuation"] },
        "human":   { pos: "noun", usecase: ["living", "user"], compatibles: ["verb", "punctuation"] },
        "monster": { pos: "noun", usecase: ["self", "scary", "identity"], compatibles: ["verb", "punctuation"] },
        "fire":    { pos: "noun", usecase: ["element", "danger", "hot"], compatibles: ["verb", "punctuation"] },

        // --- Adjectives ---
        "dangerous": { pos: "adjective", usecase: ["danger", "scary", "disaster"], compatibles: ["noun", "punctuation"] },
        "scary":     { pos: "adjective", usecase: ["danger", "fear"], compatibles: ["noun", "punctuation"] },
        "big":       { pos: "adjective", usecase: ["size"], compatibles: ["noun", "punctuation"] },
        "friendly":  { pos: "adjective", usecase: ["friend", "safe"], compatibles: ["noun", "punctuation"] },
        "wet":       { pos: "adjective", usecase: ["water", "weather"], compatibles: ["noun", "punctuation"] },

        // --- Punctuation ---
        ".": { pos: "punctuation", usecase: ["end"], compatibles: ["end"] },
        "?": { pos: "punctuation", usecase: ["end"], compatibles: ["end"] },
        "!": { pos: "punctuation", usecase: ["end"], compatibles: ["end"] }
    };

    // =========================================================
    // SYSTEM CORE (No APIs)
    // =========================================================

    const terminal = document.getElementById('terminal');
    const inputField = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');

    function log(text, type = 'log-entry') {
        const div = document.createElement('div');
        div.className = type;
        div.innerText = text;
        terminal.appendChild(div);
        terminal.scrollTop = terminal.scrollHeight;
    }

    function runFrankenstein() {
        const question = inputField.value.trim().toLowerCase();
        if(!question) return;

        inputField.value = "";
        inputField.disabled = true;
        sendBtn.disabled = true;

        log("> USER: " + question, 'user-speak');
        log("SCANNING INPUT DATA...", "debug-text");

        // 1. EXTRACT CONTEXT FROM INPUT
        // specific user logic: scan thru question and gather types
        const inputContextTags = new Set();
        const wordsInInput = question.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").split(/\s+/);

        wordsInInput.forEach(w => {
            // Check direct match
            if(DICTIONARY[w]) {
                log(` Identified known word: [${w}] -> tags: ${DICTIONARY[w].usecase}`, "debug-text");
                DICTIONARY[w].usecase.forEach(tag => inputContextTags.add(tag));
            } else {
                // If not found, use Levenshtein to see if user meant something else
                // This fits "if no matching type checks... Levenshtein"
                let bestMatch = null;
                let lowestDist = 100;
                
                Object.keys(DICTIONARY).forEach(dictWord => {
                    const dist = levenshtein(w, dictWord);
                    if (dist < 3 && dist < lowestDist) { // Strict fuzzy match
                        lowestDist = dist;
                        bestMatch = dictWord;
                    }
                });

                if(bestMatch) {
                    log(` Fuzzy Match: '${w}' identified as '[${bestMatch}]'`, "debug-text");
                    DICTIONARY[bestMatch].usecase.forEach(tag => inputContextTags.add(tag));
                }
            }
        });

        const contextArray = Array.from(inputContextTags);
        log(` COLLECTED CONTEXT: [${contextArray.join(", ")}]`, "debug-text");
        log(" INITIALIZING NEURAL GENERATION SEQUENCE...", "debug-text");

        // 2. GENERATE SENTENCE SLOWLY
        let currentWord = "start_token";
        let sentenceOutput = "";
        let steps = 0;
        let maxSteps = 15; // Don't let it loop forever

        const loop = () => {
            steps++;
            // 2a. Check if we ended
            if (currentWord === "end" || steps > maxSteps) {
                log("> AI: " + sentenceOutput, 'ai-speak');
                inputField.disabled = false;
                sendBtn.disabled = false;
                inputField.focus();
                return;
            }

            // 2b. Find Valid Candidates based on Previous Word Compatibles
            const allowedNextPOS = DICTIONARY[currentWord].compatibles;
            // Handle the unique 'End' case for punctuation
            if(allowedNextPOS.includes("end") && sentenceOutput.length > 0) {
                 // Random chance to just stop if we hit punctuation
                 if(Math.random() > 0.5) {
                    currentWord = "end";
                    setTimeout(loop, 500);
                    return;
                 }
            }

            // Filter dictionary for all words matching valid POS
            let candidates = [];
            Object.keys(DICTIONARY).forEach(key => {
                if (key === "start_token") return;
                const entry = DICTIONARY[key];
                
                if (allowedNextPOS.includes(entry.pos)) {
                    candidates.push({ word: key, entry: entry, score: 0 });
                }
            });

            // 2c. Score Candidates (The Frankenstein Logic)
            // Checks types vs input types. If no match, check Levenshtein.
            
            candidates.forEach(c => {
                let matchedTag = false;

                // Score by Meaning (Tag Overlap)
                c.entry.usecase.forEach(tag => {
                    if (contextArray.includes(tag)) {
                        c.score += 10; // High Value for relevancy
                        matchedTag = true;
                    }
                });

                // User constraint: "It also, if no matching type, checks the word's levenshtein compared to any of the words"
                if (!matchedTag) {
                    let bestLev = 100;
                    wordsInInput.forEach(inputWord => {
                        // Compare candidate word against words in input for structural similarity
                        // e.g., if user used "cat", "bat" might get a tiny boost (though tags are better)
                        let d = levenshtein(c.word, inputWord);
                        if(d < bestLev) bestLev = d;
                    });
                    
                    // The closer the Levenshtein (lower number), the higher the score
                    // Inverting it so lower distance = higher score
                    if (bestLev < 3) c.score += (5 - bestLev); 
                }

                // Randomness to stop repetitive loops
                c.score += Math.random() * 2;
            });

            // 2d. Select Winner
            if (candidates.length > 0) {
                // Sort by score descending
                candidates.sort((a, b) => b.score - a.score);
                const winner = candidates[0].word;
                
                // Visual formatting
                if (DICTIONARY[winner].pos === "punctuation") {
                    sentenceOutput += winner;
                } else {
                    sentenceOutput += (sentenceOutput.length > 0 ? " " : "") + capitalize(winner);
                }
                
                currentWord = winner;
                // Log the thought process "Slowly"
                log(`...thought '${winner}' (Score: ${candidates[0].score.toFixed(2)})`, "debug-text");

            } else {
                // Dead end logic - force end
                currentWord = "end";
            }

            // Run next word generation after delay
            setTimeout(loop, 800); 
        };

        // Start the loop
        setTimeout(loop, 500);
    }

    // =========================================================
    // UTILITIES
    // =========================================================

    // Standard Levenshtein Distance Algorithm (The Math Part)
    function levenshtein(a, b) {
        const matrix = [];
        for (let i = 0; i <= b.length; i++) matrix[i] = [i];
        for (let j = 0; j <= a.length; j++) matrix[0][j] = j;

        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) == a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1, // substitution
                        Math.min(
                            matrix[i][j - 1] + 1, // insertion
                            matrix[i - 1][j] + 1 // deletion
                        )
                    );
                }
            }
        }
        return matrix[b.length][a.length];
    }

    function capitalize(s) {
        return s.charAt(0).toUpperCase() + s.slice(1);
    }

</script>
</body>
</html>
