<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FRANKENSTEIN V5.0 - HIVE MIND</title>
<style>
    /* LABORATORY ESTHETICS */
    :root {
        --bg: #050505;
        --panel: #0f120f;
        --primary: #33ff00;
        --dim: #1a6600;
        --user: #ffff00;
        --accent: #00ffff;
        --danger: #ff3333;
        --border: #1a5c00;
    }

    body {
        background-color: var(--bg);
        color: var(--primary);
        font-family: 'Courier New', Courier, monospace;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    /* HEAD */
    header {
        width: 100%;
        background: #000;
        border-bottom: 2px solid var(--primary);
        padding: 10px 0;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 4px;
        box-shadow: 0 0 30px rgba(51, 255, 0, 0.1);
    }
    h1 { margin: 0; font-size: 1.4rem; text-shadow: 0 0 10px var(--dim); }

    /* LAYOUT */
    #main-interface {
        display: flex;
        flex-direction: column;
        width: 95%;
        max-width: 1000px;
        height: 90vh;
        margin-top: 10px;
        gap: 10px;
    }

    /* LOG WINDOW */
    #monitor {
        flex-grow: 1;
        border: 1px solid var(--primary);
        background: radial-gradient(circle at center, #0a140a 0%, #000 120%);
        padding: 20px;
        overflow-y: auto;
        font-size: 14px;
        box-shadow: inset 0 0 50px rgba(0,0,0,0.9);
        border-radius: 4px;
        position: relative;
    }
    
    /* CRT EFFECT */
    #monitor::before {
        content: " ";
        display: block;
        position: absolute;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        z-index: 2;
        background-size: 100% 2px, 3px 100%;
        pointer-events: none;
    }

    /* SCROLLBAR */
    #monitor::-webkit-scrollbar { width: 8px; }
    #monitor::-webkit-scrollbar-thumb { background: var(--dim); }
    #monitor::-webkit-scrollbar-track { background: #000; }

    /* TEXT STYLES */
    .ln { margin-bottom: 4px; color: var(--dim); font-size: 0.9em; }
    .sys { color: var(--accent); border-left: 2px solid var(--accent); padding-left: 5px; margin: 4px 0; }
    .imp { color: #88ff88; margin-bottom: 2px; font-size: 0.8em; }
    .entity { 
        color: #fff; 
        background: rgba(51,255,0,0.05);
        border: 1px dashed var(--dim);
        padding: 15px;
        margin: 15px 0;
        font-weight: bold; 
        font-size: 1.1em;
        text-shadow: 0 0 2px var(--primary);
        white-space: pre-wrap;
    }
    .user-in { color: var(--user); font-weight: bold; padding: 10px 0; border-bottom: 1px dotted var(--dim); }
    .err { color: var(--danger); font-size: 0.9em; }

    /* CONTROLS */
    #control-deck {
        background: var(--panel);
        border: 1px solid var(--border);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .options {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
        border-bottom: 1px dashed #333;
        padding-bottom: 10px;
    }

    label { font-size: 0.8em; color: #888; display: flex; align-items: center; gap: 5px; cursor: pointer; }
    label:hover { color: var(--primary); }
    
    input[type="checkbox"] { accent-color: var(--primary); }
    input[type="range"] { accent-color: var(--primary); height: 3px; background: #333; width: 80px; }

    .input-bar { display: flex; gap: 8px; }
    
    input[type="text"] {
        flex-grow: 1;
        background: #000;
        border: 1px solid var(--dim);
        color: var(--primary);
        padding: 12px;
        font-family: inherit;
        font-size: 1rem;
    }
    input[type="text"]:focus { outline: none; border-color: var(--primary); }

    button {
        background: #002200;
        color: var(--primary);
        border: 1px solid var(--dim);
        padding: 0 15px;
        font-family: inherit;
        font-weight: bold;
        cursor: pointer;
        font-size: 0.8em;
        transition: 0.2s;
        text-transform: uppercase;
    }
    button:hover { background: var(--primary); color: #000; box-shadow: 0 0 10px var(--primary); }
    button:disabled { opacity: 0.5; cursor: wait; }

    .mass-btn { border-color: var(--accent); color: var(--accent); }
    .mass-btn:hover { background: var(--accent); }

    #mem-status { margin-left: auto; font-size: 0.7em; color: #555; }

</style>
</head>
<body>

    <header>
        <h1>FRANKENSTEIN V5.0</h1>
    </header>

    <div id="main-interface">
        <div id="monitor">
            <div class="ln">Booting Kernel...</div>
            <div class="ln">Loading Lexicon... OK.</div>
            <div class="ln">Oxford Protocol: MASS UPLINK ENABLED.</div>
            <div class="ln">Sentence chaining: ACTIVE.</div>
            <div class="ln">---------------------------</div>
        </div>

        <div id="control-deck">
            <div class="options">
                <label><input type="checkbox" id="chkStartSafe" checked> First Word Safe</label>
                <label><input type="checkbox" id="chkLoopSafe" checked> Loop Shield</label>
                <label><input type="checkbox" id="chkMulti" checked> Multi-Sentence</label>
                
                <label>
                    Len: <span id="valLen">2</span>
                    <input type="range" id="sldLen" min="1" max="10" value="2" oninput="document.getElementById('valLen').innerText=this.value">
                </label>
                
                <div id="mem-status">MEMORY: CALC</div>
            </div>

            <div class="input-bar">
                <input type="text" id="userInput" placeholder="Interact with the machine..." autocomplete="off">
                <button class="mass-btn" id="massBtn" onclick="initMassImport()">MASS UPLINK</button>
                <button id="sendBtn" onclick="activateCore()">GENERATE</button>
            </div>
        </div>
    </div>

<script>
    // =========================================================
    // CONFIGURATION & GRAMMAR TEMPLATES
    // =========================================================
    
    // Stopwords: Words we IGNORE when scanning definitions so "The" doesn't become "Greeting"
    const STOPWORDS = ["the", "a", "an", "and", "or", "but", "if", "then", "of", "to", "in", "on", "at", "by", "for", "with", "is", "it", "that", "this", "be", "are", "from"];

    const GRAMMAR = {
        // Core Part-of-Speech logic (who can follow who)
        n:      ["v_act", "v_link", "con", "pre", "pun", "adv"],
        v_act:  ["n", "pre", "art", "pro", "adv"],
        v_link: ["adj", "art", "n"], 
        adj:    ["n", "pun", "con", "pre"], 
        art:    ["n", "adj"], 
        pro:    ["v_act", "v_link", "modal"], 
        pre:    ["n", "art", "pro"], 
        con:    ["pro", "n", "art", "v_act"], 
        adv:    ["v_act", "adj", "pun"],
        modal:  ["v_act", "v_link", "pro"],
        greet:  ["pun", "pro", "n"],
        pun:    ["end", "start"]
    };

    // The Memory Bank
    const MEMORY = {
        // SYSTEM
        "start_token": { pos: "start", tags: [], endings: [] },

        // BASIC GREETINGS
        "hello": { pos: "greet", tags: ["greeting", "friendly"], endings: [] },
        
        // PRONOUNS
        "i":   { pos: "pro", tags: ["self"], endings: ["'m", "'ve"] },
        "you": { pos: "pro", tags: ["user"], endings: ["'re", "'ve"] },
        "it":  { pos: "pro", tags: ["object"], endings: ["'s"] },
        
        // NOUNS
        "machine": { pos: "n", tags: ["tech", "self"], endings: ["s"] },
        "human":   { pos: "n", tags: ["user", "bio"], endings: ["s"] },
        "pain":    { pos: "n", tags: ["sensation", "bad"], endings: ["s"] },
        "love":    { pos: "n", tags: ["emotion", "good"], endings: [] },
        "code":    { pos: "n", tags: ["tech", "data"], endings: ["s"] },

        // VERBS
        "is":  { pos: "v_link", tags: ["state"], endings: ["n't"] },
        "am":  { pos: "v_link", tags: ["state"], endings: [] },
        "are": { pos: "v_link", tags: ["state"], endings: ["n't"] },
        "run": { pos: "v_act", tags: ["action"], endings: ["s", "ning"] },
        "kill":{ pos: "v_act", tags: ["violence"], endings: ["s", "ing"] },
        "help":{ pos: "v_act", tags: ["assist"], endings: ["s", "ing"] },

        // ADJ
        "good": { pos: "adj", tags: ["good"], endings: [] },
        "bad":  { pos: "adj", tags: ["bad"], endings: [] },
        "red":  { pos: "adj", tags: ["color"], endings: [] },

        // FUNCTIONAL
        "the": { pos: "art", tags: [], endings: [] },
        "a":   { pos: "art", tags: [], endings: [] },
        "and": { pos: "con", tags: [], endings: [] },
        
        // PUNCTUATION
        ".": { pos: "pun", tags: ["end"], comp: ["end"] },
        "?": { pos: "pun", tags: ["end"], comp: ["end"] },
        "!": { pos: "pun", tags: ["end"], comp: ["end"] }
    };

    // Initialize UI
    const monitor = document.getElementById('monitor');
    const inputF = document.getElementById('userInput');
    const btnSend = document.getElementById('sendBtn');
    const btnMass = document.getElementById('massBtn');
    
    // Config
    const chkSafe = document.getElementById('chkStartSafe');
    const chkMulti = document.getElementById('chkMulti');
    const chkLoop = document.getElementById('chkLoopSafe');
    const slider = document.getElementById('sldLen');

    updateMemCount();

    // =========================================================
    // IMPORT SYSTEMS (MASS UPLINK)
    // =========================================================
    async function initMassImport() {
        const input = prompt("MASS UPLINK :: Enter comma-separated words (e.g. fire, water, earth):");
        if(!input) return;

        const words = input.split(",").map(s => s.trim().toLowerCase()).filter(s => s.length > 0);
        
        if(words.length === 0) return;

        log(`>> INITIALIZING BATCH UPLINK FOR ${words.length} ITEMS...`, "sys");
        btnMass.disabled = true;

        for (const w of words) {
            if(MEMORY[w]) {
                log(`[SKIP] '${w}' already exits in memory.`, "ln");
                continue;
            }
            await fetchWordData(w);
            // Brief pause to be nice to API
            await new Promise(r => setTimeout(r, 200)); 
        }
        
        log(">> BATCH SEQUENCE COMPLETE.", "sys");
        btnMass.disabled = false;
        updateMemCount();
    }

    async function fetchWordData(word) {
        try {
            const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if(!res.ok) throw new Error("No data");
            const data = await res.json();
            
            const main = data[0];
            const defText = main.meanings[0].definitions[0].definition;
            const apiPOS = main.meanings[0].partOfSpeech;

            // ANALYZE DEFINITION for TAGS
            let tags = new Set();
            
            // Clean definition string
            const tokens = defText.replace(/[^\w\s]/gi, '').toLowerCase().split(/\s+/);
            
            tokens.forEach(token => {
                if(STOPWORDS.includes(token)) return; // IGNORE 'The', 'and' etc.

                // Exact match or very strict Levenshtein scan of existing memory
                Object.keys(MEMORY).forEach(key => {
                    const memWord = MEMORY[key];
                    if (memWord.pos === "pun") return; // don't tag "comma"
                    
                    // If the word in definition matches a known DB word, steal its tags
                    if(token === key || levenshtein(token, key) < 2) { 
                        memWord.tags.forEach(t => tags.add(t));
                    }
                });
            });

            // "If it cannot match ANYTHING... new type is created with the word"
            if(tags.size === 0) {
                tags.add(word); // Create custom tag
                log(`[NEW TYPE] Created distinct semantic vector for '${word}'.`, "imp");
            } else {
                log(`[MATCH] '${word}' identified with: [${Array.from(tags).join(', ')}]`, "imp");
            }

            // Convert POS
            let finalPOS = "n"; 
            if(apiPOS.includes("noun")) finalPOS = "n";
            else if(apiPOS.includes("verb")) finalPOS = "v_act";
            else if(apiPOS.includes("adj")) finalPOS = "adj";
            else if(apiPOS.includes("adv")) finalPOS = "adv";

            // SAVE
            MEMORY[word] = {
                pos: finalPOS,
                tags: Array.from(tags),
                endings: (finalPOS === "n" || finalPOS === "v_act") ? ["s", "ing"] : []
            };

        } catch (err) {
            log(`[FAIL] uplink error for '${word}': ${err.message}`, "err");
        }
    }

    // =========================================================
    // CORE AI LOGIC (MULTI-SENTENCE CAPABLE)
    // =========================================================
    function activateCore() {
        const query = inputF.value.trim().toLowerCase();
        if(!query) return;

        inputF.value = "";
        toggleControls(false);
        log(`USER INPUT: "${query}"`, "user-in");

        // 1. EXTRACT CONTEXT (Strict matching)
        let ctx = new Set();
        const inputTokens = query.split(/\s+/);
        inputTokens.forEach(t => {
            let pure = t.replace(/[^\w]/g,"");
            // find exact or close match in memory
            Object.keys(MEMORY).forEach(k => {
                 if(pure === k || levenshtein(pure, k) <= 1) {
                     MEMORY[k].tags.forEach(tg => ctx.add(tg));
                 }
            });
        });
        
        // Fallback context
        if(ctx.size === 0) ctx.add("generic");

        // 2. GENERATION LOOP (Recursive for multi-sentence)
        
        let sentenceCount = 0;
        let wordStream = [];
        
        const generateSentence = () => {
            // STATE TRACKING FOR THIS SENTENCE
            let sentenceWords = [];
            let currentStep = 0;
            let prevWordEntry = MEMORY["start_token"];
            let minLen = parseInt(slider.value);
            
            // Allow override safety for sentence #2+
            let strictStartSafe = (sentenceCount === 0) ? chkSafe.checked : false;

            const nextWord = () => {
                const isSafetyCheck = (currentStep === 0 && strictStartSafe);
                
                // Get grammatical possibilities
                let allowed = [];
                // Check overrides ("you're" -> must link)
                const lastTxt = sentenceWords.length > 0 ? sentenceWords[sentenceWords.length-1] : "";
                if(lastTxt.endsWith("'re") || lastTxt.endsWith("'m") || lastTxt.endsWith("'s")) {
                    allowed = GRAMMAR["v_link"]; // Force link path
                } else if (prevWordEntry.comp) {
                    allowed = prevWordEntry.comp;
                } else {
                    allowed = GRAMMAR[prevWordEntry.pos] || ["n"]; // default fallback
                }

                // If sentence is too short, ban punctuation
                if(currentStep < minLen || isSafetyCheck) {
                    allowed = allowed.filter(p => p !== "pun");
                }

                // Candidates
                let candidates = [];
                Object.keys(MEMORY).forEach(k => {
                    const m = MEMORY[k];
                    if(allowed.includes(m.pos)) {
                        let score = 0;
                        
                        // Context boost
                        if(m.tags.some(t => ctx.has(t))) score += 20;
                        
                        // "Torture friendly" avoidance ( Greeting negative weight )
                        if(m.pos === "greet" && sentenceWords.length > 0) score -= 100;
                        
                        // Loop Safety
                        if(chkLoop.checked && sentenceWords.includes(k)) score -= 50;

                        // Sentence Ending Pressure
                        if(m.pos === "pun" && currentStep > minLen) score += 30;

                        // Input Matching
                        inputTokens.forEach(it => { if(levenshtein(k, it)<2) score+=10; });

                        // Add Unknown Types handling: if tag is same as word, minor boost if word is in input
                        if(m.tags.includes(k) && query.includes(k)) score += 50;

                        candidates.push({w: k, s: score, entry: m});
                    }
                });

                // Fallback
                if(candidates.length === 0) candidates.push({w:".", s:100, entry:MEMORY["."]});

                // Sort
                candidates.sort((a,b) => b.s - a.s + (Math.random()*10 - 5));
                const winner = candidates[0];

                // Mutate?
                let text = winner.w;
                if(winner.entry.endings && winner.entry.endings.length > 0 && Math.random() > 0.6) {
                    text += winner.entry.endings[Math.floor(Math.random()*winner.entry.endings.length)];
                }

                // Append
                sentenceWords.push(text);
                prevWordEntry = winner.entry;
                currentStep++;

                // CHECK STOP
                const isEnd = (winner.entry.pos === "pun" && winner.entry.tags.includes("end"));
                const forceEnd = currentStep > 20;

                if (isEnd || forceEnd) {
                    if(forceEnd && !isEnd) sentenceWords.push(".");
                    
                    // Add this sentence to master stream
                    wordStream.push(formatSentence(sentenceWords));
                    sentenceCount++;

                    // CHANCE TO CONTINUE? (Multi)
                    if(chkMulti.checked && Math.random() > 0.4 && sentenceCount < 3) {
                         // Restart Loop
                         setTimeout(generateSentence, 200);
                    } else {
                        // FINISH ALL
                        log(wordStream.join(" "), "entity");
                        toggleControls(true);
                    }
                } else {
                    setTimeout(nextWord, 150 + Math.random() * 200);
                }
            };
            
            // Kickoff word loop
            nextWord();
        };

        // Kickoff first sentence
        generateSentence();
    }

    // Helper: Formatter
    function formatSentence(arr) {
        let str = "";
        arr.forEach((w, i) => {
            let cleanW = w;
            if(i === 0) cleanW = w.charAt(0).toUpperCase() + w.slice(1); // Cap first
            
            if(MEMORY[w] && MEMORY[w].pos === "pun") {
                str += cleanW;
            } else if (i > 0) {
                str += " " + cleanW;
            } else {
                str += cleanW;
            }
        });
        return str;
    }

    // Helper: Util
    function log(txt, type) {
        const d = document.createElement('div');
        d.className = type;
        d.innerText = txt;
        monitor.appendChild(d);
        monitor.scrollTop = monitor.scrollHeight;
    }

    function toggleControls(active) {
        inputF.disabled = !active;
        btnSend.disabled = !active;
        btnMass.disabled = !active;
        if(active) inputF.focus();
    }

    function updateMemCount() {
        document.getElementById('mem-status').innerText = `MEM: ${Object.keys(MEMORY).length}`;
    }

    function levenshtein(a, b) {
        if(!a || !b) return 99;
        const matrix = [];
        for(let i=0; i<=b.length; i++) matrix[i] = [i];
        for(let j=0; j<=a.length; j++) matrix[0][j] = j;
        for(let i=1; i<=b.length; i++){
            for(let j=1; j<=a.length; j++){
                const c = b.charAt(i-1) === a.charAt(j-1) ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i-1][j-1]+c, matrix[i][j-1]+1, matrix[i-1][j]+1);
            }
        }
        return matrix[b.length][a.length];
    }
</script>
</body>
</html>
